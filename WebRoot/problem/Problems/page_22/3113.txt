</p><div class="ptx" lang="en-US"><span lang="en-us"><p>The Halting Problem is a classic decision problem in computer science which basically requires to determine whether a given program will always stop (or terminate its execution) for an arbitrary given input or will execute infinitely. Alan Turing proved, in 1936, that it is impossible to solve the halting problem generalizing for any program-input pair. In this problem, however, given the description of a simple language, a program written in the language and an input for this program, you must determine whether the given program stops with the given input and, in the positive case, what output will be produced.</p><p>This language only works with integers from <code>0</code> to <code>999</code> (inclusive). In addition, the successor of <code>999</code> is <code>0</code>, and the predecessor of <code>0</code> is <code>999</code>. Moreover, it has ten variables (<code>R0</code> to <code>R9</code>), among which <code>R0</code> is always assigned the calling value of the program (that is, the input parameter) and <code>R9</code> is always assigned the exit (return) value. At the beginning of execution of the program, the value <code>0</code> is assigned to all these variables, with the exception of <code>R0</code>, which receives the input parameter.</p><p>The basic operations are assignment (<code>MOV</code>), addition (<code>ADD</code>), subtraction (<code>SUB</code>), multiplication (<code>MUL</code>), integer division (<code>DIV</code>) and remainder of integer division (<code>MOD</code>). All these operations have the syntax <code>COMMAND OPERAND1,OPERAND2</code> (without spaces between the comma and the operands), where <code>COMMAND</code> is one of these operations, <code>OPERAND1</code> is one of the 10 variables (<code>R0</code> to <code>R9</code>) and <code>OPERAND2</code> can be one of the 10 variables or an integer value (between <code>0</code> and <code>999</code>). All the operations modify the value of <code>OPERAND1</code>, consequently <code>MOV R4,100</code> is equivalent to assigning the value <code>100</code> to <code>R4</code>, while <code>MUL R3,R8</code> is equivalent to multiplying <code>R3</code> by <code>R8</code> and assigning the result to <code>R3</code>. The operation <code>DIV</code>, as well as <code>MOD</code>, returns <code>0</code> (zero) if <code>OPERAND2</code> is <code>0</code> or the equivalent variable has the value <code>0</code>. That is, <code>DIV R4,0</code> is equivalent to multiplying <code>MOV R4,0</code>. By integer division, we mean the integral part of the quotient of the division (without the fractional part). For example, the integer division of <code>7</code> by <code>2</code> is <code>3</code> (with remainder <code>1</code>).</p><p>There exist six decision flow commands: <code>IFEQ</code> (if equal), <code>IFNEQ</code> (if different), <code>IFG</code> (if greater), <code>IFL</code> (if less), <code>IFGE</code> (if greater or equal) and <code>IFLE</code> (if less or greater). The syntax of all of them is <code>COMMAND OPERAND1,OPERAND2</code> (without spaces between the comma and the operands), where both <code>OPERAND1</code> and <code>OPERAND2</code> can be variables (<code>R0</code> to <code>R9</code>) or integer values (between <code>0</code> and <code>999</code>). Thus, the command <code>IFEQ R4,123</code> is equivalent to testing whether <code>R4</code> is equal to <code>123</code>. When the tested condition is true, the program continues to execute normally the line subsequent to the decision command. When the condition is false, the program proceeds to execute the line subsequent to the nearest following <code>ENDIF</code>. <b>All</b> the decision commands must have a corresponding <code>ENDIF</code> command.</p><p>Finally, there exist the commands <code>CALL</code> and <code>RET</code>, both with the syntax <code>COMMAND OPERAND</code>, where <code>OPERAND</code> is a variable (<code>R0</code> to <code>R9</code>) or a direct value (between <code>0</code> and <code>999</code>). The command <code>CALL</code> calls the program recursively, passing <code>OPERAND</code> as the input parameter, that is, assigning the value of <code>OPERAND</code> to variable <code>R0</code>. And <code>RET</code> terminates the execution of the program, returning the value of <code>OPERAND</code> as the output result. <b>The last line of the program will always be a command</b> <code>RET</code>. It can be observed that, if the program calls itself through the command <code>CALL</code>, when execution returns, the value of <code>R9</code> is going to be changed with the value returned by the program. Note also that <b>all</b> the variables (<code>R0</code> to <code>R9</code>) are local, that is, a subsequent call to the program cannot change values saved in the variables of previous instance, with the exception of, naturally, the value of <code>R9</code>, which receives the return value of the called instance.</p><p>The following example illustrates a program that calculates the factorial of a number.</p><div align="center"><table border="1" cellpadding="2" style="border-collapse: collapse" bordercolor="#000000"><tr><td align="center">line</td><td align="center">command</td></tr><tr><td align="center">1</td><td align="center"><code>IFEQ R0,0</code></td></tr><tr><td align="center">2</td><td align="center"><code>RET 1</code></td></tr><tr><td align="center">3</td><td align="center"><code>ENDIF</code></td></tr><tr><td align="center">4</td><td align="center"><code>MOV R1,R0</code></td></tr><tr><td align="center">5</td><td align="center"><code>SUB R1,1</code></td></tr><tr><td align="center">6</td><td align="center"><code>CALL R1</code></td></tr><tr><td align="center">7</td><td align="center"><code>MOV R2,R9</code></td></tr><tr><td align="center">8</td><td align="center"><code>MUL R2,R0</code></td></tr><tr><td align="center">9</td><td align="center"><code>RET R2</code></td></tr></table></div><ul><li>The 1st line: Check if the value of <code>R0</code> is <code>0</code>, if true, execute the next line; if not, jump to the 4th line (past the nearest following <code>ENDIF</code>).</li><li>The 2nd line: Return <code>1</code> as the output of the program.</li><li>The 3rd line: Mark the end of the decision block started at the first line.</li><li>The 4th line: Assign the value of <code>R0</code> to <code>R1</code> (<code>R0 &larr; R1</code>).</li><li>The 5th line: Subtract <code>1</code> from <code>R1</code> (<code>R0 &larr; R0 - 1</code>).</li><li>The 6th line: Call the program passing <code>R1</code> as the input parameter.</li><li>The 7th line: Save the value of <code>R9</code> (returned by the call before) in <code>R2</code> (<code>R2 &larr; R9</code>).</li><li>The 8th line: Multiply the value of <code>R2</code> by <code>R0</code> (<code>R2 &larr; R2 * R0</code>).</li><li>The 9th line: Return the value of <code>R2</code> as the output of the program.</li></ul><p>The following table holds a resume of the commands for reference.</p><div align="center"><table border="1" cellpadding="2" style="border-collapse: collapse" bordercolor="#000000"><tr><td align="center">command</td><td align="center">syntax</td><td align="center">meaning</td></tr><tr><td align="center"><code>MOV</code></td><td align="center"><code>MOV OP1,OP2</code></td><td align="center"><code>OP1 &larr; OP2</code></td></tr><tr><td align="center"><code>ADD</code></td><td align="center"><code>ADD OP1,OP2</code></td><td align="center"><code>OP1 &larr; OP1 + OP2</code></td></tr><tr><td align="center"><code>SUB</code></td><td align="center"><code>SUB OP1,OP2</code></td><td align="center"><code>OP1 &larr; OP1 - OP2</code></td></tr><tr><td align="center"><code>MUL</code></td><td align="center"><code>MUL OP1,OP2</code></td><td align="center"><code>OP1 &larr; OP1 * OP2</code></td></tr><tr><td align="center"><code>DIV</code></td><td align="center"><code>DIV OP1,OP2</code></td><td align="center"><code>OP1 &larr; OP1 / OP2</code></td></tr><tr><td align="center"><code>MOD</code></td><td align="center"><code>MOD OP1,OP2</code></td><td align="center"><code>OP1 &larr; OP1 % OP2</code></td></tr><tr><td align="center"><code>IFEQ</code></td><td align="center"><code>IFEQ OP1,OP2</code></td><td align="center"><code>IF OP1 == OP2</code></td></tr><tr><td align="center"><code>IFNEQ</code></td><td align="center"><code>IFNEQ OP1,OP2</code></td><td align="center"><code>IF OP1 != OP2</code></td></tr><tr><td align="center"><code>IFG</code></td><td align="center"><code>IFG OP1,OP2</code></td><td align="center"><code>IF OP1 &gt; OP2</code></td></tr><tr><td align="center"><code>IFL</code></td><td align="center"><code>IFL OP1,OP2</code></td><td align="center"><code>IF OP1 &lt; OP2</code></td></tr><tr><td align="center"><code>IFGE</code></td><td align="center"><code>IFGE OP1,OP2</code></td><td align="center"><code>IF OP1 &gt;= OP2</code></td></tr><tr><td align="center"><code>IFLE</code></td><td align="center"><code>IFLE OP1,OP2</code></td><td align="center"><code>IF OP1 &lt;= OP2</code></td></tr><tr><td align="center"><code>ENDIF</code></td><td align="center"><code>ENDIF</code></td><td align="center">Mark the end of a conditional execution block</td></tr><tr><td align="center"><code>CALL</code></td><td align="center"><code>CALL OP</code></td><td align="center">Call the program will <code>OP</code> as input</td></tr><tr><td align="center"><code>RET</code></td><td align="center"><code>RET OP</code></td><td align="center"><code>return OP</code></td></tr></table></div></span></div><p class="pst">Input</p><div class="ptx" lang="en-US"><span lang="en-us"><p>The input contains several test cases. Each test case starts with two integers, <i>L</i> and <i>N</i>, representing respectively the number of lines of the program (1 &le; <i>L</i> &le; 100) and the value of the input parameter of the program (0 &le; <i>N</i> &lt; 1000). The following L lines contain the program. It can be assumed that it is always syntactically correct in accordance with the rules defined above. All the commands (as well as the variables) only contain capital letters. The end of the input is marked by a case where <i>L</i> = <i>N</i> = 0 which should not be processed.</p></span></div><p class="pst">Output</p><div class="ptx" lang="en-US"><p>For each test case, your program should produce one line containing an integer which represents the exit (return) value for the given input <i>N</i>, or an asterisk (*) in the case that the program never terminates.</p></div><p class="pst">Sample Input</p><pre class="sio">9 6
IFEQ R0,0
RET 1
ENDIF
MOV R1,R0
SUB R1,1
CALL R1
MOV R2,R9
MUL R2,R0
RET R2
2 123
CALL R0
RET R0
0 0</pre><p class="pst">Sample Output</p><pre class="sio">720
*</pre><p class="pst">