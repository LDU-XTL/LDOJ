</p><div class="ptx" lang="en-US"><p>A diamond puzzle is played on a tessellated hexagon like the one shown in <b>Figure 1</b> below. And in this problem the faces produced by the tessellation are identified as they are numbered in the same figure. If two faces share a side, they are called neighboring faces. Thus, even-numbered faces have three neighboring faces, while odd-numbered faces have only two. At any point during the play of the puzzle, six of the seven faces hold a unique digit ranging from 1 to 6, and the other one is empty. A move in the puzzle is to move a digit from one face to a neighboring empty one.</p><div align="center"><img src="images/3221_1.png"></div><p>Starting from any configuration, some series of moves can always make the puzzle look identical to either one shown in <b>Figures 2</b> and <b>3</b>. Your task is to calculate the minimum number of moves to make it become the one in <b>Figure 2</b>.</p></div><p class="pst">Input</p><div class="ptx" lang="en-US"><span lang="en-us"><p>The input contains multiple test cases. The first contains an integer <i>N</i> (0 ≤ <i>N</i> ≤ 5,040), the number of test cases. Then follow <i>N</i> lines, each with a permutation of {0, 1, 2, 3, 4, 5, 6} describing a starting configuration of the puzzle. The <i>i</i>th digit in the permutation is the one in the face numbered <i>i</i> − 1. A zero means the face is empty.</p></span></div><p class="pst">Output</p><div class="ptx" lang="en-US"><span lang="en-us"><p>For each test cases, output the minimum number of moves the configuration takes to reach the one shown in <b>Figure 2</b>. If this is impossible, just output “<code>-1</code>” and nothing else.</p></span></div><p class="pst">Sample Input</p><pre class="sio">3
1324506
2410653
0123456</pre><p class="pst">Sample Output</p><pre class="sio">10
-1
0</pre><p class="pst">