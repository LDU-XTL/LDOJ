</p><div class="ptx" lang="en-US"><p>Recently Vasya became acquainted with an interesting movement in mathematics and logic called &ldquo;intuitionism&rdquo;. The main idea of this movement consists in the rejection of the law of excluded middle (the logical law stating that any assertion is either true or false). Vasya liked this idea; he says: &ldquo;Classical mathematics says that Fermat Last Theorem is either true or false; but this statement is completely useless for me until I see the proof or a contrary instance&rdquo;. So Vasya became a born-again intuitionist. He tries to use the intuitionistic logic in all his activities and especially in his scientific work. But this logic is much more diffcult than the classic one. Vasya often tries to use logical formulae that are valid in classical logic but aren't so in the intuitionistic one.</p><p>Now he wants to write a program that will help him to check the validity of his formulae automatically. He has found a book describing how to do that but unfortunately he isn&rsquo;t good at programming, so you&rsquo;ll have to help him.</p><p>The construction start from an arbitrary acyclic oriented graph <i>X</i> = (<i>&Chi;</i>, <i>G</i>). Then a partial order is constructed on <i>X</i>, the set of vertices of <i>&Chi;</i>: for any <i>x</i>, <i>y</i> &isin; <i>&Chi;</i> we define <i>x</i> &le; <i>y</i> iff there exists a path (possibly of zero length) in <i>X</i> from <i>x</i> to <i>y</i>. Next, consider the set <i>&Beta;</i> of all subsets of <i>&Chi;</i> and the set <i>&Eta;</i> &sub; <i>&Beta;</i> consisting of all <i>&alpha;</i> &sub; <i>&Chi;</i> such that any two different <i>x</i> and <i>y</i> from <i>&alpha;</i> are incomparable (i.e. neither <i>x</i> &le; <i>y</i> nor <i>y</i> &le; <i>x</i>). Note that <i>&Eta;</i> always contains the empty set and all one-element subsets of <i>&Chi;</i> Now it is possible to define a map <i>Max</i> : <i>&Beta;</i> &rarr; <i>&Eta;</i> &sub; <i>&Beta;</i>. For any <i>M</i> &sub; <i>&Chi;</i> we put <i>Max</i>(<i>M</i>) = { x &isin; <i>M</i> : &not;&exist;<i>y</i> &isin; <i>M</i> : <i>x</i> &ne; <i>y</i>, <i>x</i> &le; <i>y</i> } &ndash; the set of all maximal elements of <i>M</i>.</p><p>Next we define several operations on <i>&Eta;</i>. For any <i>&alpha;</i>, <i>&beta;</i> &isin; <i>&Eta;</i> we put <i>&alpha;</i> &and; <i>&beta;</i> = <i>Max</i>(<i>&alpha;</i> &cup; <i>&beta;</i>), <i>&alpha;</i> &or; <i>&beta;</i> = <i>Max</i>({ <i>x</i> &isin; <i>&Chi;</i> : &exist;<i>y</i> &isin; <i>&alpha;</i>, <i>z</i> &isin; <i>&beta;</i> : <i>x</i> &le; <i>y</i>, <i>x</i> &le; <i>z</i> }), <i>&alpha;</i> &hArr; <i>&beta;</i> = { <i>x</i> &isin; <i>&beta;</i> : &not;&exist;<i>y</i> &isin; <i>&alpha;</i> : <i>x</i> &le; <i>y</i> }, 0 = <i>Max</i>(<i>&Chi;</i>), 1 = &Oslash;, &not;<i>&alpha;</i> = (<i>&alpha;</i> &rArr; 0), <i>&alpha;</i> &equiv; <i>&beta;</i> = ((<i>&alpha;</i> &rArr; <i>&beta;</i>) &and; (<i>&beta;</i> &rArr; <i>&alpha;</i>)).</p><p>Now consider logical formulae consisting of the following symbols:</p><ul><li>Constants 1 and 0; </li><li>Variables &ndash; capital letters from A to Z; </li><li>Parentheses &ndash; if <i>E</i> is a formula, then (<i>E</i>) is another; </li><li>Negation &ndash; &not;<i>E</i> is a formula for any formula <i>E</i>; </li><li>Conjunction &ndash; <i>E</i><sub>1</sub> &and; <i>E</i><sub>2</sub> &and; &hellip; &and; <i>E<sub>n</sub></i>. Note that the conjunction is evaluated from left to right: <i>E</i><sub>1</sub> &and; <i>E</i><sub>2</sub> &and; <i>E</i><sub>3</sub> = (<i>E</i><sub>1</sub> &and; <i>E</i><sub>2</sub>) &and; <i>E</i><sub>3</sub>. </li><li>Disjunction &ndash; <i>E</i><sub>1</sub> &or; <i>E</i><sub>2</sub> &or; &hellip; &or; <i>E<sub>n</sub></i>. The same remark applies. </li><li>Implication &ndash; <i>E</i><sub>1</sub> &rArr; <i>E</i><sub>2</sub>. Unlike the previous two operations it is evaluated from right to left: <i>E</i><sub>1</sub> &rArr; <i>E</i><sub>2</sub> &rArr; <i>E</i><sub>3</sub> means <i>E</i><sub>1</sub> &rArr; (<i>E</i><sub>2</sub> &rArr; <i>E</i><sub>3</sub>). </li><li>Equivalence &ndash; <i>E</i><sub>1</sub> &equiv; <i>E</i><sub>2</sub> &equiv; &hellip; &equiv; <i>E<sub>n</sub></i>. This expression is equal to (<i>E</i><sub>1</sub> &equiv; <i>E</i><sub>2</sub>) &and; (<i>E</i><sub>2</sub> &equiv; <i>E</i><sub>3</sub>) &and; &hellip; &and; (<i>E</i><sub><i>n</i> &minus; 1</sub> &equiv; <i>E<sub>n</sub></i>). </li></ul><p>The operations are listed from the highest priority to the lowest.</p><p>A formula <i>E</i> will be called <i>valid</i> (in the model defined by <i>X</i>) if after substitution of arbitrary elements of <i>&Eta;</i> for the variables involved in <i>E</i> it evaluates to 1; otherwise it is called <i>invalid</i>. </p><p>Your task is to determine for a given graph <i>X</i> and a set of formulae which of them are valid and which invalid.</p></div><p class="pst">Input</p><div class="ptx" lang="en-US"><p>For each case the first line contains two integers <i>N</i> and <i>M</i> separated by a single space &ndash; the number of vertices (1 &le; <i>N</i> &le; 100) and edges (0 &le; <i>M</i> &le; 5000) of <i>X</i>. The next <i>M</i> lines contain two integers <i>s<sub>i</sub></i> and <i>t<sub>i</sub></i> each &ndash; the beginning and the end of <i>i</i>-th edge respectively. The next line contains <i>K</i> (1 &le; <i>K</i> &le; 20) &ndash; the number of formulae to be processed. The following <i>K</i> lines contain one formula each. A formula is represented as a string consisting of tokens <tt>0</tt>, <tt>1</tt>, <tt>A</tt> &hellip; <tt>Z</tt>, <tt>(</tt>, <tt>)</tt>, <tt>~</tt>, <tt>&amp;</tt>, <tt>|</tt>, <tt>=&gt;</tt>, <tt>=</tt>. The last five tokens stand for &not;, &and;, &or;, &rArr; and &equiv; respectively. Tokens can be separated by an arbitrary number of spaces. No line will be longer than 254 characters. All formulae in the file will be syntactically correct. Also you may assume that the number <i>H</i> = ||<i>&Eta;</i>|| of elements of <i>&Eta;</i> doesn&rsquo;t exceed 100 and that the sum &sum;<sub>1 &le; <i>j</i> &le; <i>K</i></sub> <i>H</i><sup><i>v</i>[<i>j</i>]</sup> &le; 10<sup>6</sup> where <i>v</i>[<i>j</i>] is the number of different variables used in <i>j</i>-th formula.</p></div><p class="pst">Output</p><div class="ptx" lang="en-US"><p>For each test case, print <i>K</i> lines &ndash; one line for each formula. Write to the <i>j</i>-th line either &ldquo;<tt>valid</tt>&rdquo; or &ldquo;<tt>invalid</tt>&rdquo;.</p></div><p class="pst">Sample Input</p><pre class="sio">6 6
1 2
2 3
2 4
3 5
4 5
5 6
11
1=0
X|~X
A=>B=>C = (A&B)=>C
~~X => X
X => ~~X
(X => Y) = (Y | ~X)
A&(B|C) = A&B|A&C
(X=>A)&(Y=>A) => X|Y=>A
X = ~~X
~X=~~~X
~X = (X => 0)</pre><p class="pst">Sample Output</p><pre class="sio">invalid
invalid
valid
invalid
valid
invalid
valid
valid
invalid
valid
valid</pre><p class="pst">